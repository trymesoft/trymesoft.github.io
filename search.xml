<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试环境 MySQL 版本升级导致的一些问题]]></title>
    <url>%2F2019%2F01%2Fmysql-upgrade-problems%2F</url>
    <content type="text"><![CDATA[原因某些项目的创建时间字段需要精确到毫秒级，该字段类型是 timestamp，参考 MySQL 5.7 官方文档，0 在日期相关字段中的含义不同，如下表： Data Type “Zero” Value DATE “0000-00-00” TIME “00:00:00” DATETIME “0000-00-00 00:00:00” TIMESTAMP “0000-00-00 00:00:00” YEAR 0000 由此，可以看到无论是 DATETIME 还是 TIMESTAMP 字段属性，默认都是精确到秒的。 查阅资料发现，可以通过 TIMESTAMP(n) 来指定精确度，实际修改中发现当前数据库版本是 5.5，执行字段类型更改时一直报错，但是在 5.7 版本中可以正常修改字段类型，后将数据库更新到 5.7 版本，emm…，迎来升级的同时，小问题也是不少。 问题及解决mysql.user 表结构的改变5.5 和 5.7 版本的 mysql.user 表结构不同（暂不仔细探讨），导致项目中需要连接 MySQL 数据库的地方全部认证失败 Access denied for test@192.168.53.6，但是，该表中的数据全部正常，内网全部可连接，尝试重置密码： 1set password for 'test@192.168.%.%' = password('test666'); 执行报错： 12ERROR 1805 (HY000): Column count of mysql.user is wrong. Expected 42, found 49. The table is probably corrupted 查询资料发现，是数据库升级导致的，两个版本的表结构不同，只好执行升级命令： 1mysql_upgrade -u root -p 输入 root 密码等待执行完毕之后再更改密码，SQL 语句执行成功，再刷新权限即可： 1flush privileges; GROUP BY 问题日志报错： 1Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.user.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by; 可以看到是 sql_mode=only_full_group_by 的问题，查看官方文档，发现默认的 sql_mode 中有 only_full_group_by，该配置导致 GROUP BY 后的列必须在 SELECT 的列中。 执行： 1select @@sql_mode; 查看当前 sql_mode，将 only_full_group_by 删除即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 的缓存导致热部署的问题]]></title>
    <url>%2F2019%2F01%2Fidea-hotswap-thymeleaf-cache%2F</url>
    <content type="text"><![CDATA[使用 IDEA 热部署项目时，之前的项目配置完成后，页面文件改动或者 Java 文件改动都能即时热部署，但是在公司一个项目中，热部署突然失效，折腾了半天😭。 起因因为要接手一个项目，在部署调试的过程中，发现页面的热部署在 IDEA 中不好用，当页面中的代码更改时，无论是 IDEA 手动 update 还是失去焦点，虽然出发了热部署，但是页面文件分明有了改动，但是总是提示 Loaded classes are up to date.Nothing to reload，很是奇怪🤔，后来改动 Java 文件，热部署没问题，真是哔了🐶了。 解决开始以为是自己配置配置的问题，可之前的项目也是这么配置的，有问题早就暴露出来了，不应该是配置的问题。 在 Dont&#39;t be evil --- Google 的网站上遨游了一番，找了好多答案都不是想要的，终于在下班前夕被我找到了😎，答案在这里。 原来是 Thymeleaf 的缓存😂，赶紧去查看配置文件，发现了 Thymeleaf 的配置： 12345678...&lt;bean id="templateResolver" class="org.thymeleaf.templateresolver.ServletContextTemplateResolver"&gt; ... &lt;property name="cacheable" value="true"/&gt; &lt;property name="cacheTTLMs" value="#&#123;60*60*1000&#125;"/&gt; ...&lt;/bean&gt;... 都是这个 cacheable 的锅，改为 false ，重启后一切正常，又能愉快的玩耍了😊。]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 事务捕获异常后无法回滚]]></title>
    <url>%2F2019%2F01%2Ftransaction-not-rollback%2F</url>
    <content type="text"><![CDATA[当前配置由于项目是 SSM 框架整合而成，MySQL 的事务配置如下： 12345678910111213141516171819202122232425262728293031&lt;!--数据源配置--&gt;&lt;bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc_url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc_username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc_password&#125;" /&gt;&lt;/bean&gt;&lt;!--事务管理配置--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!--切面配置--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;tx:method name="find*" read-only="true" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--AOP 配置--&gt;&lt;aop:config&gt; &lt;!--把事务控制在 Service 层--&gt; &lt;aop:pointcut id="allServiceMethod" expression="execution(* com.test.*.service..*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="allServiceMethod" /&gt;&lt;/aop:config&gt;&lt;!-- 开启注解方式配置事物 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 问题分析在一个事务管理的接口，方法抛出了 NullPointerException 异常，但是有关数据库表的操作却没有回滚，伪代码片段如下： 123456789...try &#123; noticeMapper.insert(notice); noticeLogMapper.insert(noticeLog);&#125; catch (Exception e) &#123; LOGGER.error("数据插入异常！！！"); e.printStackTrace();&#125;... 在 noticeLog 的插入过程中代码抛出了异常，但是 notice 却成功的插入到了数据库，相当于这个明明被事务管理的方法在遇到程序异常却没有回滚事务🤔。 查阅文档及资料，在 Spring 官方文档中有解释： 注意中间红框段落，翻译一下： 123In its default configuration, the Spring Framework’s transaction infrastructure code marks a transaction for rollback only in the case of runtime, unchecked exceptions. That is, when the thrown exception is an instance or subclass of RuntimeException. ( Error instances also, by default, result in a rollback). Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration. 在其默认配置中，Spring Framework的事务基础结构代码仅在运行时未经检查的异常情况下标记回滚事务。也就是说，抛出的异常是RuntimeException的实例或子类。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的已检查异常不会导致在默认配置中回滚。 可以看到代码抛出 RuntimeException 的实例、子类或在默认情况下的 Error 才会导致回滚，但是，从事务方法抛出的已检查异常不会导致在默认配置中回滚。 所以代码中 try catch 捕获了异常，导致了事务无法回滚(⊙x⊙)。 解决方案方案一既然代码的异常被捕获后事务无法回滚，那么可以手动抛出 RuntimeException 的实例或子类： 12345678910...try &#123; noticeMapper.insert(notice); noticeLogMapper.insert(noticeLog);&#125; catch (Exception e) &#123; LOGGER.error("数据插入异常！！！"); e.printStackTrace(); throw new RuntimeException();&#125;... 方案二既然事务没有自动回滚，我们可以手动设置事务的回滚： 12345678910...try &#123; noticeMapper.insert(notice); noticeLogMapper.insert(noticeLog);&#125; catch (Exception e) &#123; LOGGER.error("数据插入异常！！！"); e.printStackTrace(); TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();&#125;... 再次调试运行后，事务正常回滚😊。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大版本更新上线问题汇总]]></title>
    <url>%2F2019%2F01%2Fnew-version-problems%2F</url>
    <content type="text"><![CDATA[Tomcat 容器启动问题 前提 Spring Boot 版本 2.0.3.RELEASE druid-spring-boot-starter 版本 1.1.9 mysql-connector-java 版本 5.1.46 MySQL 数据库版本 5.7 Tomcat 版本 7.0.67（最终升级了版本到 Tomcat 8） JDK 版本 1.7（最终升级到1.8） 问题： 测试、生产配置文件属性不同步，生产环境很多属性未配置，导致错误注入。解决： 将所有注入的 API 地址同步。 问题： 启动时 Dubbo 报错，找不到服务。 解决： 提供者所在机器 Dubbo 端口未开放，开放对应端口即可。 问题： Tomcat 无法启动，每次启动报不同的错误。 解决： JDK版本升级到 1.8→Tomcat 版本升级到 7.0.92 问题： java.lang.NoClassDefFoundError: javax/el/ELManager 解决：参考 问题： 配置： 1234567# MySQL数据源配置 datasource: driver-class-name: com.mysql.jdbc.Driver druid: url: jdbc\:mysql\://rds.xxx.com\:3306/xxx?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull username: xxx password: password 异常信息： 1234567891011Caused by: java.sql.SQLException: connect error, url jdbc\:mysql\://rds.xxx.com\:3306/xxx?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull, driverClass com.mysql.jdbc.Driver at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1582) at com.alibaba.druid.pool.DruidDataSource.init(DruidDataSource.java:859) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1833) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1776) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1704) ... 116 more 解决： 异常信息里非常明确的提及是数据库连接 url 的问题，在 Spring Boot 的 yml 配置文件中，格式为：property: value 属性名称加「:」之后有一个空格，项目之前的配置文件中 MySQL 数据库的连接地址转义过，这里直接复制过来使用，是行不通的，将转义字符「\」去掉即可。 Tomcat 重启之后异常问题： 异常信息： 12345678910111213org.apache.catalina.session.StandardManager doLoadSEVERE: IOException while loading persisted sessions: java.io.EOFExceptionjava.io.EOFException at java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2298) at java.io.ObjectInputStream$BlockDataInputStream.readShort(ObjectInputStream.java:2767) at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:798) at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:298) ...org.apache.catalina.session.StandardManager startInternalSEVERE: Exception loading sessions from persistent storagejava.io.EOFException ... 解决： 删除 ${catalina.home}/work/Catalina/localhost/${APP-NAME}/SESSION.ser 即可 问题： Dubbo 报错 报错信息： 12345672018-12-15 20:26:52,387 [DubboSaveRegistryCache-thread-1] WARN [com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry] - [DUBBO] Failed to save registry store file, cause: Can not lock the registry cache file /root/.dubbo/dubbo-registry-10.11.12.13.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties, dubbo version: 2.5.3, current host: 10.20.30.40java.io.IOException: Can not lock the registry cache file /root/.dubbo/dubbo-registry-10.11.12.13.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties at com.alibaba.dubbo.registry.support.AbstractRegistry.doSaveProperties(AbstractRegistry.java:193) at com.alibaba.dubbo.registry.support.AbstractRegistry$SaveProperties.run(AbstractRegistry.java:150) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745) Dubbo 会使用文件缓存注册中心地址列表及服务提供者列表，默认路径在 /${user.home}/.dubbo/dubbo-registry-10.20.30.40.cache，应用重启时将基于此文件恢复，一台服务器有多个应用使用这个文件恢复时，会出现这个警告。 解决： 可以在每个项目 Dubbo 配置文件中的 dubbo:registry 标签中的 file 指定不同的文件路径。 官方文档 参考地址 问题： Tomcat 容器无日志输出logback-spring.xml配置：12345678910...&lt;!-- 测试环境+开发环境. --&gt; &lt;springProfile name="test,dev"&gt; &lt;logger name="com.xxx.im" level="INFO"/&gt; &lt;/springProfile&gt; &lt;!-- 生产环境 --&gt; &lt;springProfile name="prod"&gt; &lt;logger name="com.xxx.im" level="ERROR"/&gt; &lt;/springProfile&gt;... 解决： 生产环境日志输出级别过高，INFO 级别的无法输出，将 ERROR 改为 INFO 即可。 转战华为云之后🙂 RabbitMQ 连接 Spring Boot 版本 2.0.3.RELEASE 问题： RabbitMQ 直接使用 yaml 配置如下： 123456spring: rabbitmq: host: rabbitmq.xxx.com username: user password: password123456 port: 5672 项目启动时报错信息： 123... ...ForgivingExceptionHandler - An unexpected connection driver error occured (Exception message: Connection closed)... 解决： 从异常日志中可以很明显的看到，是 Connection closed，解决思路如下： 初步判断当前机器无法连通 RabbitMQ 所在机器，使用 ping rabbitmq.xxx.com 命令可以 ping 通 RabbitMQ 所在机器，并且 telnet rabbitmq.xxx.com 5672 也是可以连通的，排除此原因； 确认 username、password 准确性，发现 RabbitMQ 是新装的，使用命令查看其用户： 123[root@rabbit ~]# rabbitmqctl list_usersListing users ...admin [administrator] 发现并没有 user 这个用户，创建用户： 12[root@rabbit ~]# rabbitmqctl add_user user password123456Creating user "user" ... 设置为管理员： 12[root@rabbit ~]# rabbitmqctl set_user_tags user administratorSetting tags for user "user" to [administrator] ... 此时，使用该用户登录 RabbitMQ WEB 端管理页面后查看该用户信息：点击 Set permission 配置权限，重启项目后问题解决。 Tomcat 问题问题： 启动 Tomcat 容器报错信息如下： 123org.apache.tomcat.jni.Error: 70023: This function has not been implemented on this platform at org.apache.tomcat.jni.SSL.initialize(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 解决： 修改 $TOMCAT_HOME/conf/server.xml 中的 &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;off&quot; /&gt; 即可解决。 Tomcat 问题问题： 启动 Tomcat 容器报错信息如下： 123org.apache.tomcat.jni.Error: 70023: This function has not been implemented on this platform at org.apache.tomcat.jni.SSL.initialize(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 解决： 修改 $TOMCAT_HOME/conf/server.xml 中的 &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;off&quot; /&gt; 即可解决。 线上问题处理问题： MongoDB 版本：TokuMX 2.0.2 | MongoDB 2.4 spring-data-mongodb 版本：1.4.1.RELEASE spring-data-commons 版本：1.7.2.RELEASE 12345678java.lang.IllegalArgumentException: You have to provide at least one property to sort by! at org.springframework.data.domain.Sort.&lt;init&gt;(Sort.java:91) at org.springframework.data.domain.Sort.&lt;init&gt;(Sort.java:79) ... at sun.reflect.GeneratedMethodAccessor415.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) ... 解决： 异常信息很明确，未提供排序的属性，检查代码，异常代码片段如下： 123456789101112... @Autowired private MongoTemplate mongoTemplate;... Query query = new Query();List&lt;String&gt; sortStrList = new ArrayList&lt;&gt;();if (...) &#123; sortStrList.add("property"); &#125;query.with(new Sort(Sort.Direction.DESC, sortStrList.toArray(new String[sortStrList.size()]))) mongoTemplate.find(query, Xxx.class);... 很明显，排序属性集合 sortStrList 中有可能没有任何属性，再查看 org.springframework.data.domain.Sort 中的构造方法： 123456789101112131415161718public Sort(Sort.Direction direction, String... properties) &#123; this(direction, (List)(properties == null ? new ArrayList() : Arrays.asList(properties)));&#125;public Sort(Sort.Direction direction, List&lt;String&gt; properties) &#123; if (properties != null &amp;&amp; !properties.isEmpty()) &#123; this.orders = new ArrayList(properties.size()); Iterator i$ = properties.iterator(); while(i$.hasNext()) &#123; String property = (String)i$.next(); this.orders.add(new Sort.Order(direction, property)); &#125; &#125; else &#123; throw new IllegalArgumentException("You have to provide at least one property to sort by!"); &#125;&#125; 可以看出，sortStrList 完全无需转换为数组，但这不是主要原因，从下面的构造方法中可以看出，传入的 List 集合不可为空对象并且必须集合大小必须大于 0，所以解决方案可以有多种，只需控制 sortStrList 集合不为空且 size 大于 0，或者根据判断查询不加排序条件也可以解决。 问题： 12345678910111213141516171819org.springframework.data.mongodb.UncategorizedMongoDbException: Lock not granted. Try restarting the transaction.; nested exception is com.mongodb.MongoException: Lock not granted. Try restarting the transaction. at org.springframework.data.mongodb.core.MongoExceptionTranslator.translateExceptionIfPossible(MongoExceptionTranslator.java:83) at org.springframework.data.mongodb.core.MongoTemplate.potentiallyConvertRuntimeException(MongoTemplate.java:1828) at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:409) at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:995) at org.springframework.data.mongodb.core.MongoTemplate.updateFirst(MongoTemplate.java:969) ... at sun.reflect.GeneratedMethodAccessor378.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80) ... at sun.reflect.GeneratedMethodAccessor200.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) 解决： 手动配置的 MongoDB 事务问题，尚未彻底解决。 问题： Spring 整合 MongoDB配置文件： 1234567891011&gt; &lt;bean id="mongoOptions" class="com.mongodb.MongoOptions"&gt;&gt; ...&gt; &lt;!-- 连接超时时间(毫秒)，默认为4000 --&gt;&gt; &lt;property name="connectTimeout" value="4000" /&gt;&gt; &lt;!-- socket读写时超时时间(毫秒)，默认为0，不超时 --&gt;&gt; &lt;property name="socketTimeout" value="0" /&gt;&gt; &lt;!-- 是socket连接在防火墙上保持活动的特性，默认为false --&gt;&gt; &lt;property name="socketKeepAlive" value="true" /&gt;&gt; ...&gt; &lt;/bean&gt;&gt; 1234567891011121314151617181920212223242526272829303132333435org.springframework.dao.DataAccessResourceFailureException: can't say something; nested exception is com.mongodb.MongoException$Network: can't say something at org.springframework.data.mongodb.core.MongoExceptionTranslator.translateExceptionIfPossible(MongoExceptionTranslator.java:56) at org.springframework.data.mongodb.core.MongoTemplate.potentiallyConvertRuntimeException(MongoTemplate.java:1828) at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:409) at org.springframework.data.mongodb.core.MongoTemplate.insertDBObject(MongoTemplate.java:893) at org.springframework.data.mongodb.core.MongoTemplate.doInsert(MongoTemplate.java:713) at org.springframework.data.mongodb.core.MongoTemplate.insert(MongoTemplate.java:668) at org.springframework.data.mongodb.core.MongoTemplate.insert(MongoTemplate.java:659) at net.okdi.o2o.core.helper.ExceptionHelper.afterThrow(ExceptionHelper.java:71) at sun.reflect.GeneratedMethodAccessor438.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) ... at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)Caused by: com.mongodb.MongoException$Network: can't say something at com.mongodb.DBTCPConnector.say(DBTCPConnector.java:194) at com.mongodb.DBTCPConnector.say(DBTCPConnector.java:155) at com.mongodb.DBApiLayer$MyCollection.insert(DBApiLayer.java:249) at com.mongodb.DBApiLayer$MyCollection.insert(DBApiLayer.java:205) at com.mongodb.DBCollection.insert(DBCollection.java:57) at com.mongodb.DBCollection.insert(DBCollection.java:100) at org.springframework.data.mongodb.core.MongoTemplate$8.doInCollection(MongoTemplate.java:898) at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:407) ... 44 moreCaused by: java.io.IOException: couldn't connect to [mongodb.xxx.com/192.168.1.22:27017] bc:java.net.SocketTimeoutException: connect timed out at com.mongodb.DBPort._open(DBPort.java:214) at com.mongodb.DBPort.go(DBPort.java:107) at com.mongodb.DBPort.go(DBPort.java:88) at com.mongodb.DBPort.findOne(DBPort.java:143) at com.mongodb.DBPort.runCommand(DBPort.java:148) at com.mongodb.DBPort.checkAuth(DBPort.java:307) at com.mongodb.DBTCPConnector.say(DBTCPConnector.java:180) ... 51 more 解决： 异常最后很明确的提示了 connect timed out 连接超时的问题，我们可以将 connectTimeout 连接超时属性适当扩大，如果是提示 read timed out，原因是在进行数据操作时过长时间没有返回结果，此时要修改 socketTimeout 属性了。 参考文章]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot war 包方式启动问题]]></title>
    <url>%2F2019%2F01%2Fspring-boot-war-problems%2F</url>
    <content type="text"><![CDATA[Spring Boot 支持 jar 包和 war 包两种打包方式。jar 包方式运行简单，对于轻量的项目，从构造到部署极大的提升了效率；war 包方式对于启动参数、集群配置来说可能更方便一些。在使用 war 包方式的时候遇到了一个问题，记录下来📝。 前提概要 Spring Boot 版本2.0.3.RELEASE 打包方式 12- JDK1.8 编码 UTF-8- 依赖只引入了``` spring-boot-starter-web、spring-boot-starter-test Tomcat 版本 7.0.82 问题配置好项目及 Tomcat 部署后启动失败，有这么一行异常信息：1Caused by: java.lang.NoClassDefFoundError: javax/el/ELManager 解决路径缺少 jar 包第一反应，缺少 jar 包，在 pom 文件引入：12345&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 重新启动后问题仍然存在，加入 &lt;scope&gt;provided&lt;/scope&gt; 后仍然不行，失败。 hibernate-validator 版本过高搜索后有文章说是 当前版本的 Spring Boot，依赖的验证 hibernate-validator 版本太高，导致找不到 ELManager。查看项目依赖树，发现是web 依赖中的查看其他项目中同样写法并不报错，排除这种原因。 Tomcat 版本有人说 Tomcat7 提供的 el-api.jar 版本是 2.2，Tomcat8 的版本是 3.0，未尝试切换 Tomcat版本。 最终解决将下载的 el-api3.0 的 jar 包拷贝到 $TOMCAT_HOME/lib 下替换之前的 el-api.jar 即可。 参考地址：stackoverflow]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 使用中的小问题总结]]></title>
    <url>%2F2019%2F01%2Fspring-boot-use-problems%2F</url>
    <content type="text"><![CDATA[Spring Boot 使用中遇到的问题总结，持续更新… IDEA 中读取配置文件问题问题如图：解决方案：引入如下依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 此时会出现如下图：可以直接忽略。 Tomcat 容器启动过慢的问题启动项目时，明明一个很简单的项目，却启动很慢，Tomcat 日志中有这么一行：1WARNING: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [20,617] milliseconds. 启动成功耗时：1INFO: Server startup in 33239 ms 这个警告的操作耗了大半的启动时间，查阅 Tomcat 的wiki发现这么一段话：解释得很清楚，Tomcat 启动时熵源的生成默认是 JRE 的阻塞式熵源（/ dev / random），替换为非阻塞式熵源（/ dev /./ urandom）即可，但是会降低安全性，因为获得的随机数据较少。修改方式：直接修改 $JAVA_HOME/jre/lib/security/java.security 中1securerandom.source=file:/dev/./urandom 或者直接执行1java -jar app.jar -Djava.security.egd=file:/dev/./urandom 修改完再启动：1INFO: Server startup in 10847 ms 效果还是很显著的😊。 静态变量的注入日常开发中，一般常用的工具会抽取到工具类中，工具类中的方法一般都是静态调用的，方法中可能会注入其他成员变量，由于方法是 static 的，所以成员变量也必须是静态的。此时，使用 @Autowired 已经无法注入，此时就需要新的操作了😏。首先，将需要使用的定义为静态变量：1private static RestTemplate restTemplate; 然后生成 set 方法并在方法上加 @Autowired（读取属性文件的话使用 @Value）注解（注意不要加 static）：1234@Autowired public void setRestTemplate(RestTemplate restTemplate) &#123; AuthTokenUtil.restTemplate = restTemplate; &#125; 最后，类上加上 @Component注解即可。 RestTemplate 的 GET 请求的 Headers 设置RestTemplate 介绍 Spring’s central class for synchronous client-side HTTP access. It simplifies communication with HTTP servers, and enforces RESTful principles. It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. Spring 的同步客户端 HTTP 访问的中心类。它简化了与 HTTP 服务器的通信，并实施了 RESTful 原则。它处理 HTTP 连接，使应用程序代码提供 URL（带有可能的模板变量）并提取结果。 环境配置 Spring Boot 版本 2.0.3.RELEASE spring-web-5.0.7.RELEASE.jar 的 RestTemplate RestTemplate 的配置 12345678910111213141516171819202122232425262728293031323334import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestFactory;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;/** * @author tryme.wang * @create 2018-11-30 10:59:48 * @description RestTemplate配置 **/@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123; RestTemplate restTemplate = new RestTemplate(factory); return restTemplate; &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123; /** * 默认情况下，RestTemplate依赖于标准JDK工具来建立HTTP连接。 * 可以通过InterceptingHttpAccessor.setRequestFactory（org.springframework.http.client.ClientHttpRequestFactory） * 属性切换到使用不同的HTTP库，例如Apache HttpComponents，Netty和OkHttp。 */ SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); // 单位：ms factory.setReadTimeout(5000); // 单位：ms factory.setConnectTimeout(15000); return factory; &#125;&#125; 方案RestTemplate 使用时可能会有 Headers 中需要传入 token 之类参数的情况，使用 POST 请求时，RestTemplate 的 API 中有明显的方法postForEntity或postForObject： 然而 GET 请求并没有明显可以理解的 API 使用，查阅资料发现了 exchange 方法可以指定 HTTP 请求方式： ok，就它了，而且其他请求方式均可以使用这个来执行 Headers。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestTemplate 自定义 ErrorHandler]]></title>
    <url>%2F2019%2F01%2Fresttemplate-errorhandler%2F</url>
    <content type="text"><![CDATA[在使用 Spring Boot 的 RestTemplate 调用时，发现调用成功时很好用，但是服务器返回 4xx 或者 5xx 异常时，这货直接给抛出来了，想要处理可以自定义 ErrorHandler。 问题当服务端返回非 200 时，调用方直接抛出如下异常：12345678910org.springframework.web.client.HttpClientErrorException: 400 Bad Request at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:94) at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:79) at org.springframework.web.client.ResponseErrorHandler.handleError(ResponseErrorHandler.java:63) at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:766) at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:724) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:680) at org.springframework.web.client.RestTemplate.postForEntity(RestTemplate.java:466) ... 为什么会抛异常呢，可以翻一下源码：RestTemplate 中12345public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = this.httpEntityCallback(request, responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = this.responseEntityExtractor(responseType); return (ResponseEntity)nonNull(this.execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables)); &#125; 继续翻：12345@Nullable public &lt;T&gt; T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables) throws RestClientException &#123; URI expanded = this.getUriTemplateHandler().expand(url, uriVariables); return this.doExecute(expanded, method, requestCallback, responseExtractor); &#125; 再往下：123456789101112131415161718192021222324252627282930@Nullable protected &lt;T&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor) throws RestClientException &#123; Assert.notNull(url, "URI is required"); Assert.notNull(method, "HttpMethod is required"); ClientHttpResponse response = null; Object var14; try &#123; ClientHttpRequest request = this.createRequest(url, method); if (requestCallback != null) &#123; requestCallback.doWithRequest(request); &#125; response = request.execute(); this.handleResponse(url, method, response); var14 = responseExtractor != null ? responseExtractor.extractData(response) : null; &#125; catch (IOException var12) &#123; String resource = url.toString(); String query = url.getRawQuery(); resource = query != null ? resource.substring(0, resource.indexOf(63)) : resource; throw new ResourceAccessException("I/O error on " + method.name() + " request for \"" + resource + "\": " + var12.getMessage(), var12); &#125; finally &#123; if (response != null) &#123; response.close(); &#125; &#125; return var14; &#125; 继续：123456789101112131415protected void handleResponse(URI url, HttpMethod method, ClientHttpResponse response) throws IOException &#123; ResponseErrorHandler errorHandler = this.getErrorHandler(); boolean hasError = errorHandler.hasError(response); if (this.logger.isDebugEnabled()) &#123; try &#123; this.logger.debug(method.name() + " request for \"" + url + "\" resulted in " + response.getRawStatusCode() + " (" + response.getStatusText() + ")" + (hasError ? "; invoking error handler" : "")); &#125; catch (IOException var7) &#123; &#125; &#125; if (hasError) &#123; errorHandler.handleError(url, method, response); &#125; &#125; 终于看到了想要的，可以看出 hasError 为 true，即有错误时，会走 errorHandler.handleError(url, method, response)，接下来继续查看这个 errorHandler 的源码：123456789public interface ResponseErrorHandler &#123; boolean hasError(ClientHttpResponse var1) throws IOException; void handleError(ClientHttpResponse var1) throws IOException; default void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException &#123; this.handleError(response); &#125;&#125; 这是一个接口，我们点进它的实现类 DefaultResponseErrorHandler 的 handleError()12345678public void handleError(ClientHttpResponse response) throws IOException &#123; HttpStatus statusCode = HttpStatus.resolve(response.getRawStatusCode()); if (statusCode == null) &#123; throw new UnknownHttpStatusCodeException(response.getRawStatusCode(), response.getStatusText(), response.getHeaders(), this.getResponseBody(response), this.getCharset(response)); &#125; else &#123; this.handleError(response, statusCode); &#125; &#125; 继续往下：12345678910protected void handleError(ClientHttpResponse response, HttpStatus statusCode) throws IOException &#123; switch(statusCode.series()) &#123; case CLIENT_ERROR: throw new HttpClientErrorException(statusCode, response.getStatusText(), response.getHeaders(), this.getResponseBody(response), this.getCharset(response)); case SERVER_ERROR: throw new HttpServerErrorException(statusCode, response.getStatusText(), response.getHeaders(), this.getResponseBody(response), this.getCharset(response)); default: throw new UnknownHttpStatusCodeException(statusCode.value(), response.getStatusText(), response.getHeaders(), this.getResponseBody(response), this.getCharset(response)); &#125; &#125; 可算找到原因了，原来在这里抛出了一个 HttpClientErrorException，既然 DefaultResponseErrorHandler 实现了 ResponseErrorHandler，而且从名字上看貌似是个默认的错误处理，那我们可以尝试自定义 ErrorHandler 实现 ResponseErrorHandler 来处理异常情况。 自定义 ErrorHandler1234567891011121314151617181920212223import org.springframework.http.client.ClientHttpResponse;import org.springframework.web.client.DefaultResponseErrorHandler;import java.io.IOException;/** * @author tryme.wang * @create 2018-12-03 11:10 * @description 远程调用自定义异常Handler **/public class RestErrorHandler extends DefaultResponseErrorHandler &#123; @Override public boolean hasError(ClientHttpResponse response) throws IOException &#123; // 是否有错 返回false即手动设置了不管response是什么都没有错 return false; &#125; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; // 暂时空着 &#125;&#125; 别忘记配置进去：1234567891011121314151617181920212223242526272829303132import com.merrichat.im.common.handler.RestErrorHandler;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestFactory;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;/** * @author tryme.wang * @create 2018-11-30 10:59:48 * @desc http请求配置 （替代httpclient） **/@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123; RestTemplate restTemplate = new RestTemplate(factory); // 使用自定义的ErrorHandler restTemplate.setErrorHandler(new RestErrorHandler()); return restTemplate; &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123; SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); // 单位：ms factory.setReadTimeout(5000); // 单位：ms factory.setConnectTimeout(15000); return factory; &#125;&#125; 这样无论服务端返回什么状态码，客户端都会认为没错，我们就可以获取想要的 statusCode 或者 body 进而来处理各种业务了😉。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 字段默认值的问题]]></title>
    <url>%2F2019%2F01%2Fmysql-column-default-value%2F</url>
    <content type="text"><![CDATA[前提使用 SQL 脚本创建表的时候，遇到了一个问题，SQL 脚本如下： 123456create table test( ... create_time datetime not null default now() comment &apos;创建时间&apos;, ...) 在为”create_time“字段设置默认值为当前时间时，SQL 执行报了一个错误如下： 1[42000][1067] Invalid default value for &apos;create_time&apos; 字段默认值无效的原因，查看了下当前的 MySQL 版本： 1234567mysql&gt; select version();+------------+| version() |+------------+| 5.5.35-log |+------------+1 row in set (0.00 sec) 版本是 5.5 的。 解决思路查看了 MySQL 5.5 的文档，在 Data Type Default Values 这一段中有这么个描述： 12With one exception, the default value specified in a DEFAULT clause must be a literal constant; it cannot be a function or an expression. This means, for example, that you cannot set the default for a date column to be the value of a function such as NOW() or CURRENT_DATE. The exception is that, for a TIMESTAMP column, you can specify CURRENT_TIMESTAMP as the default. See Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”. （除了一个例外，DEFAULT子句中指定的默认值必须是文字常量;它不能是一个功能或表达。这意味着，例如，您不能将日期列的默认值设置为函数的值，例如NOW（）或CURRENT_DATE。例外情况是，对于TIMESTAMP列，您可以将CURRENT_TIMESTAMP指定为默认值。请参见第11.3.5节“TIMESTAMP的自动初始化和更新”。） 原因很明显了，DEFAULT 指定的默认值不能是 NOW() ，可以将 ”create_time“字段的类型改为 TIMESTAMP，再将默认值设为 CURRENT_TIMESTAMP 来使用。 PS：MySQL 5.6/5.7 版本中，对于默认值的描述有所变化： 12With one exception, the default value specified in a DEFAULT clause must be a literal constant; it cannot be a function or an expression. This means, for example, that you cannot set the default for a date column to be the value of a function such as NOW() or CURRENT_DATE. The exception is that, for TIMESTAMP and DATETIME columns, you can specify CURRENT_TIMESTAMP as the default. See Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP and DATETIME”. （除了一个例外，DEFAULT子句中指定的默认值必须是文字常量;它不能是一个功能或表达。这意味着，例如，您不能将日期列的默认值设置为函数的值，例如NOW（）或CURRENT_DATE。例外情况是，对于TIMESTAMP和DATETIME列，您可以将CURRENT_TIMESTAMP指定为默认值。请参见第11.3.5节“TIMESTAMP和DATETIME的自动初始化和更新”。） 可以看到，后续版本中 DATETIME 类型的字段也可以将 CURRENT_TIMESTAMP 设为默认值。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 发布的服务和 AOP 无法共存的问题]]></title>
    <url>%2F2019%2F01%2Fdubbo-service-aop-conflict%2F</url>
    <content type="text"><![CDATA[Spring Boot 使用中遇到的问题总结，持续更新… IDEA 中读取配置文件问题问题如图：解决方案：引入如下依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 此时会出现如下图：可以直接忽略。 Tomcat 容器启动过慢的问题启动项目时，明明一个很简单的项目，却启动很慢，Tomcat 日志中有这么一行：1WARNING: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [20,617] milliseconds. 启动成功耗时：1INFO: Server startup in 33239 ms 这个警告的操作耗了大半的启动时间，查阅 Tomcat 的wiki发现这么一段话：解释得很清楚，Tomcat 启动时熵源的生成默认是 JRE 的阻塞式熵源（/ dev / random），替换为非阻塞式熵源（/ dev /./ urandom）即可，但是会降低安全性，因为获得的随机数据较少。修改方式：直接修改 $JAVA_HOME/jre/lib/security/java.security 中1securerandom.source=file:/dev/./urandom 或者直接执行1java -jar app.jar -Djava.security.egd=file:/dev/./urandom 修改完再启动：1INFO: Server startup in 10847 ms 效果还是很显著的😊。 静态变量的注入日常开发中，一般常用的工具会抽取到工具类中，工具类中的方法一般都是静态调用的，方法中可能会注入其他成员变量，由于方法是 static 的，所以成员变量也必须是静态的。此时，使用 @Autowired 已经无法注入，此时就需要新的操作了😏。首先，将需要使用的定义为静态变量：1private static RestTemplate restTemplate; 然后生成 set 方法并在方法上加 @Autowired（读取属性文件的话使用 @Value）注解（注意不要加 static）：1234@Autowired public void setRestTemplate(RestTemplate restTemplate) &#123; AuthTokenUtil.restTemplate = restTemplate; &#125; 最后，类上加上 @Component注解即可。 RestTemplate 的 GET 请求的 Headers 设置RestTemplate 介绍 Spring’s central class for synchronous client-side HTTP access. It simplifies communication with HTTP servers, and enforces RESTful principles. It handles HTTP connections, leaving application code to provide URLs (with possible template variables) and extract results. Spring 的同步客户端 HTTP 访问的中心类。它简化了与 HTTP 服务器的通信，并实施了 RESTful 原则。它处理 HTTP 连接，使应用程序代码提供 URL（带有可能的模板变量）并提取结果。 环境配置 Spring Boot 版本 2.0.3.RELEASE spring-web-5.0.7.RELEASE.jar 的 RestTemplate RestTemplate 的配置 12345678910111213141516171819202122232425262728293031323334import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestFactory;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;/** * @author tryme.wang * @create 2018-11-30 10:59:48 * @description RestTemplate配置 **/@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123; RestTemplate restTemplate = new RestTemplate(factory); return restTemplate; &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123; /** * 默认情况下，RestTemplate依赖于标准JDK工具来建立HTTP连接。 * 可以通过InterceptingHttpAccessor.setRequestFactory（org.springframework.http.client.ClientHttpRequestFactory） * 属性切换到使用不同的HTTP库，例如Apache HttpComponents，Netty和OkHttp。 */ SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); // 单位：ms factory.setReadTimeout(5000); // 单位：ms factory.setConnectTimeout(15000); return factory; &#125;&#125; 方案RestTemplate 使用时可能会有 Headers 中需要传入 token 之类参数的情况，使用 POST 请求时，RestTemplate 的 API 中有明显的方法postForEntity或postForObject： 然而 GET 请求并没有明显可以理解的 API 使用，查阅资料发现了 exchange 方法可以指定 HTTP 请求方式： ok，就它了，而且其他请求方式均可以使用这个来执行 Headers。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aria2&AriaNG、OneIndex 配置]]></title>
    <url>%2F2018%2F11%2Faria2-oneindex%2F</url>
    <content type="text"><![CDATA[Aria2 介绍 aria2 is a lightweight multi-protocol &amp; multi-source command-line download utility. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink. aria2 can be manipulated via built-in JSON-RPC and XML-RPC interfaces. (from https://aria2.github.io) 安装 Aria2下载脚本并运行1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh 运行脚本后会出现以下菜单选项：12345678910111213141516171819202122 Aria2 一键安装管理脚本 [v1.1.9] -- Toyo | doub.io/shell-jc4 -- 0. 升级脚本———————————— 1. 安装 Aria2 2. 更新 Aria2 3. 卸载 Aria2———————————— 4. 启动 Aria2 5. 停止 Aria2 6. 重启 Aria2———————————— 7. 修改 配置文件 8. 查看 配置信息 9. 查看 日志信息 10. 配置 自动更新 BT-Tracker服务器———————————— 当前状态: 已安装 并 已启动 请输入数字 [0-10]: 按提示操作即可。PS:启动： /etc/init.d/aria2 start停止： /etc/init.d/aria2 stop当前状态： /etc/init.d/aria2 status配置文件路径： /root/.aria2/aria2.conf令牌密钥： 随机生成，可以更改下载目录：/usr/local/caddy/www/aria2/Download来源：逗比教程 安装 AriaNG 由于 Aria2 是一个命令行下载工具，每次使用敲命令下载文件不方便，有大佬开发出的开源 WEB 面板来管理下载任务。其中之一便是 AriaNG。AriaNG 只是一个 WEB 端的管理面板，可以远程连接 Aria2，二者可以分处不同服务器。 直接从 GitHub 项目主页下载解压到服务器即可，此时即可通过 IP 或配置好的域名进行访问。具体效果可访问 http://aria2.tryme.wang查看 安装 OneIndex可以使用宝塔面板新建网站，全程 WEB 面板操作，简单粗暴。安装参考：宝塔OneIndex 项目主页：https://github.com/donwa/oneindex下载：1git clone https://github.com/donwa/oneindex.git 移动到网站根目录后要分配权限：1chmod 777 ./config &amp;&amp; chmod 777 ./cache 此时根据配置的域名，访问 http://xxx.com/?/admin，默认的密码是 oneindex，按照提示配置即可。PS：可以配置 Nginx 伪静态去掉管理页面 URL 中的“?”，伪静态配置如下：123if (!-e $request_filename) &#123; rewrite / /?/ last;&#125; 配置 Aria2 下载后自动上传新建一个脚本文件：1vi /root/.aria2/oneindexup.sh 复制以下内容：1234567891011121314151617181920212223242526#!/bin/bashpath=$3 #取原始路径，我的环境下如果是单文件则为/data/demo.png,如果是文件夹则该值为文件夹内某个文件比如/data/a/b/c/d.jpgdownloadpath='/usr/local/caddy/www/aria2/Download' #修改成Aria2下载文件夹domain='tryme.wang' #修改成自己域名if [ $2 -eq 0 ] then exit 0fiwhile true; do #提取下载文件根路径，如把/data/a/b/c/d.jpg变成/data/afilepath=$pathpath=$&#123;path%/*&#125;; if [ "$path" = "$downloadpath" ] &amp;&amp; [ $2 -eq 1 ] #如果下载的是单个文件 then php /www/wwwroot/$domain/one.php upload:file $filepath /$folder/ rm -rf $filepath php /www/wwwroot/$domain/one.php cache:refresh exit 0elif [ "$path" = "$downloadpath" ] then php /www/wwwroot/$domain/one.php upload:folder $filepath /$folder/ rm -rf "$filepath/" php /www/wwwroot/$domain/one.php cache:refresh exit 0fidone 给脚本分配可执行权限：1chmod +x /root/.aria2/oneindexup.sh 最后写入配置文件，即上面安装 Aria2 时的配置文件 /root/.aria2/aria2.conf编辑配置文件或者直接命令：1echo "on-download-complete=/root/.aria2/oneindexup.sh" &gt;&gt;/root/.aria2/aria2.conf 参考自：Rat‘s大佬]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
        <tag>OneIndex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openfire 集成已有数据库用户]]></title>
    <url>%2F2018%2F11%2Fopenfire-database%2F</url>
    <content type="text"><![CDATA[Openfire 安装完成后，后台会默认在指定的数据库中生成 of* 等许多表，但是实际开发中往往需要集成已有的数据库表，可以通过更改系统属性来实现（用户认证，不包含群组）。 准备工作首先，业务系统中需存在用户认证相关信息表以便集成。123456789create table im_user( member_id bigint null, mobile varchar(255) null, email varchar(255) null, username varchar(255) null, password varchar(255) null, create_time timestamp null) 更改 ofproperty 表系统默认验证类：Openfire 提供了 MySQL 数据库的验证类，路径为 org.jivesoftware.openfire.auth.JDBCAuthProvider，以及用户相关的操作类org.jivesoftware.openfire.user.JDBCUserProvider，我们可以通过新建相关属性、更改验证方式和用户相关操作来达到使用已有 MySQL 数据库表的目的。 执行以下 SQL 语句新建系统属性（同样可以在管理页面操作）：123456789101112insert into `myopenfire`.ofproperty(name,propValue)values('admin.authorizedJIDs','admin@localhost'),('jdbcProvider.driver','com.mysql.jdbc.Driver'),('jdbcProvider.connectionString','jdbc:mysql://192.168.53.61:3306/myopenfire?user=test&amp;password=test&amp;rewriteBatchedStatements=true&amp;useUnicode=true&amp;characterEncoding=utf8'),('jdbcAuthProvider.passwordSQL','SELECT password FROM im_user WHERE mobile=?'),('jdbcAuthProvider.passwordType','plain'),('jdbcUserProvider.loadUserSQL','SELECT username,email FROM im_user WHERE mobile=?'),('jdbcUserProvider.userCountSQL','SELECT COUNT(*) FROM im_user'),('jdbcUserProvider.allUsersSQL','SELECT username FROM im_user'),('jdbcUserProvider.usernameField','username'),('jdbcUserProvider.nameField','mobile'),('jdbcUserProvider.emailField','email'); 将系统属性更改为以上两个类即可。 admin.authorizedJIDs 属性即管理员账户名称，@ 后是初始配置的域，必须带上，并且 im_user 表中必须有 admin 相关的验证信息才能登录管理页面。 参考：官方文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Openfire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 导入 Openfire 源码]]></title>
    <url>%2F2018%2F11%2Fimport-openfire-source%2F</url>
    <content type="text"><![CDATA[Openfire 是一个是一个 IM（即时通讯）服务器，使用 Java 编写的 XMPP 服务器，开发过程 Intellij IDEA 导入 Openfire 源码步骤比较复杂，记录一下。 下载源码从 GitHub 项目主页下载源码或者从官网下载。 导入到 IDEA 中选择 Import Project一路next即可导入成功。 进行构建注意：由于需要 ant 相关 jar 包，可以下载之后，将 ant.jar 导入到 $JAVA_HOME/jre/lib 目录下即可。添加之后进行编译报错：解决：配置 JDK 配置 application 启动应用成功启动后进入 http://localhost:9000 页面报错如下：解决：将 $OPENFIRE_HOME/src/resources/jar/admin-sidebar.xml及$OPENFIRE_HOME/resources/i18n 下所有文件拷贝到输出目录。输出目录：再次启动即可进入初始化配置页面。 管理页面配置根据提示配置即可。 至此，IDEA 导入 Openfire 源码完成！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Openfire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 RSS 服务 Tiny Tiny RSS]]></title>
    <url>%2F2018%2F11%2Finstall-ttrss%2F</url>
    <content type="text"><![CDATA[RSS 已经逐渐没落，被如今大数据信息流，推荐算法所取代。如今虽然用的人比较少，但是好在没那么多烦人的“专属广告”及宣称“千人千面”的🌶🐔算法推荐。虽然有很多 RSS 提供商，例如 Feedly、Inoreader等，也各有免费的方案，但是好的服务终究是走向了付费时代。本文主要介绍 Docker 下安装 Tiny Tiny RSS 的方法及开启 HTTPS 支持，Docker 可以理解为一种宿主机上的完全隔离的容器，安装卸载容器内的东西完全不影响宿主机。 开始安装安装 Docker 环境执行命令：1$ curl https://get.docker.io/ | sh 如果主机位于国内，可以切换为国内镜像安装脚本：1$ curl -sSL https://get.daocloud.io/docker | sh 开始部署参考 HenryQW 的方法通过 docker-compose 部署，需要安装 docker-compose 命令，一步步执行以下命令：123$ yum -y install epel-release$ yum -y install python-pip$ pip install docker-compose docker-compose.yml 内容：12345678910111213141516171819202122232425version: "3"services: database.postgres: image: sameersbn/postgresql:latest container_name: postgres environment: - PG_PASSWORD=tt-rss # please change the password - DB_EXTENSION=pg_trgm restart: always rss: image: wangqiru/ttrss:latest container_name: ttrss ports: - 181:80 environment: - SELF_URL_PATH=https://rss.tryme.wang/ # please change to your own domain, keep https there and no port for https support later - DB_HOST=database.postgres - DB_PORT=5432 - DB_NAME=ttrss - DB_USER=postgres - DB_PASS=tt-rss # please change the password stdin_open: true tty: true restart: always command: sh -c 'sh /wait-for database.postgres:5432 -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/' 在 docker-compose.yml 目录下执行：1$ docker-compose up -d 等待部署完成。 Nginx HTTPS 支持添加 Nginx yum 资源库；1$ rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 使用 yum 命令安装 Nginx：1$ yum install -y nginx 启动 Nginx：1$ service nginx start 这时访问即可看到“Welcome to Nginx”欢迎页。 使用 Let’sEncrypt 提供的免费 HTTPS 证书123$ wget https://dl.eff.org/certbot-auto$ chmod a+x ./certbot-auto$ certbot-auto 根据提示生成即可。编辑/etc/nginx/conf.d/ttrss.conf（没有的话手动创建），保存如下内容：12345678910111213141516171819202122232425262728293031323334upstream ttrssdev &#123; server 127.0.0.1:181;&#125;server &#123; listen 80; server_name rss.tryme.wang; #return 301 https://rss.tryme.wang$request_uri; rewrite ^(.*)$ https://$host$1 permanent;&#125;server &#123; listen 443 ssl; gzip on; server_name rss.tryme.wang; ssl_certificate /etc/letsencrypt/live/rss.tryme.wang/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/rss.tryme.wang/privkey.pem; access_log /var/log/nginx/ttrssdev_access.log combined; error_log /var/log/nginx/ttrssdev_error.log; location / &#123; proxy_redirect off; proxy_pass http://ttrssdev; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Frame-Options SAMEORIGIN; client_max_body_size 100m; client_body_buffer_size 128k; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; &#125;&#125; 确保/etc/nginx/nginx.conf主配置文件http块里有“include /etc/nginx/conf.d/*.conf;”验证并更新 Nginx 配置12$ nginx -t$ nginx -s reload 这是直接访问 https://rss.tryme.wang 即可看到登录页面，默认用户名 admin，密码 password，建议立即修改默认密码！ 可能出现的问题GCP 的机器直接访问域名的时候 Nginx 的错误日志可能会出现下面问题：1*33 connect() to 127.0.0.1:181 failed (13: Permission denied) while connecting to upstream 解决方案参考 地址]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typecho 加密文章显示标题]]></title>
    <url>%2F2018%2F11%2Ftypecho-encrypt-show-title%2F</url>
    <content type="text"><![CDATA[Typecho 的文章可以加密，但是加密的文章标题默认显示的是“此内容被密码保护”，什么文章都不知道😶，不过还好可以更改配置。 解决方案在 $SITE_HOME/var/Widget/Abstract/Contents.php 文件的如图位置： 将 $value[‘title’] = _t(‘此内容被密码保护’) 注释掉即可，当然，也可以修改上面的 请输入密码以访问 和 提交 为自定义内容。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typecho 文章支持 emoji]]></title>
    <url>%2F2018%2F11%2Ftypecho-support-emoji%2F</url>
    <content type="text"><![CDATA[在 MySQL 数据库中，我们常用的 utf-8 格式编码最多支持 3 个字节，而 emoji 表情是 4 个字节的符号，所以 emoji 表情的长度就超出了我们常用 utf-8 的字符集范围而无法存储。从 MySQL5.5 开始，可以更改数据库和数据表的编码为 utf8mb4 使其支持存储 emoji，utf8mb4 兼容 utf8，且比 utf8 能表示更多的字符，是 utf8 字符集的超集。修改之前一定要备份数据！修改之前一定要备份数据！修改之前一定要备份数据！ 1. 更改数据库的排序规则 2. 点击 SQL 按钮，执行以下 SQL 语句(将 Typecho 修改为自己对应的前缀)1234567alter table typecho_comments convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_contents convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_fields convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_metas convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_options convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_relationships convert to character set utf8mb4 collate utf8mb4_unicode_ci;alter table typecho_users convert to character set utf8mb4 collate utf8mb4_unicode_ci; 修改完之后： 3. 编辑网站根目录的 config.inc.php 文件，文件末尾1234567891011/** 定义数据库参数 */$db = new Typecho_Db('Pdo_Mysql', 'typecho_');$db-&gt;addServer(array ( 'host' =&gt; 'localhost', 'user' =&gt; 'username', 'password' =&gt; 'password', 'charset' =&gt; 'utf8mb4',// 将utf-8修改为utf8mb4 'port' =&gt; '3306', 'database' =&gt; 'database-name',), Typecho_Db::READ | Typecho_Db::WRITE);Typecho_Db::set($db); 按照以上步骤修改完之后，文章即可支持 emoji 表情。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot2.X 拦截器配置]]></title>
    <url>%2F2018%2F07%2Fspringboot-interceptor%2F</url>
    <content type="text"><![CDATA[Spring Boot2.0 之后的拦截器配置和之前不太一样，但是殊途同归，特此总结一下😝 Spring Boot2.0 之前Spring Boot2.0 之前的拦截器配置如下：123456789101112@Configurationpublic class InterceptorConfigurerAdapter extends WebMvcConfigurerAdapter &#123; @Bean RestRequestValidatorInterceptor restRequestValidatorInterceptor() &#123; return new RestRequestValidatorInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(restRequestValidatorInterceptor()).addPathPatterns("/**") .excludePathPatterns("/push/test"); &#125;&#125; 这是没问题的，但是在 Spring Boot2.0 或更高版本中，WebMvcConfigurerAdapter 类已经 deprecated：虽然过期，但是可以看到 WebMvcConfigurerAdapter 实现了 WebMvcConfigurer 接口，所以可以直接自定义类实现 WebMvcConfigurer 接口，其他不变。 Spring Boot2.0 之后只需要将之前继承的 WebMvcConfigurerAdapter 类改为实现 WebMvcConfigurer 接口。123456789101112@Configurationpublic class InterceptorConfigurerAdapter implements WebMvcConfigurer &#123; @Bean RestRequestValidatorInterceptor restRequestValidatorInterceptor() &#123; return new RestRequestValidatorInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(restRequestValidatorInterceptor()).addPathPatterns("/**") .excludePathPatterns("/push/test"); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件 MD5、SHA1、SHA256 校验]]></title>
    <url>%2F2018%2F05%2Ffile-verify%2F</url>
    <content type="text"><![CDATA[网上下载很多文件，都会提供 MD5 或者 SHA256 校验，防止文件内容被篡改，文件下载到本地后， 我们可以对文件进行校验。 Windows 环境下在 Windows 操作系统环境下，计算这几个常用的校验值需要下载一款软件 [MD5 &amp; SHA Checksum Utility ](https://raylin.wordpress.com/downloads/md5-sha-1-checksum-utility/)，下载后即可使用。 Linux 环境下Linux 下有 md5sum 命令，sha1sum 命令和 sha256sum 命令来计算文件相对应的值，具体使用如下： 12345678910111213[root@iz2ze0ibk1pvak9ckuwb5yz /]# md5sum test.txt 2f6c38be914b756fde482fff83064d37 test.txt[root@iz2ze0ibk1pvak9ckuwb5yz /]# sha1sum test.txt 228dfdb10e9ad6fdf5ca97f402355df1952112fe test.txt[root@iz2ze0ibk1pvak9ckuwb5yz /]# sha256sum test.txt d8a0785f3ce124ee8c79c172eefdc6989141aafaf9deab2dac8437ed5e60f5c4 test.txt macOS 环境下macOS 下有 MD5 命令和 shasum 命令，具体使用如下： 12345678910111213wangyxdeMBP:~ wangyx$ md5 test.txtMD5 (test.txt) = af7bbf6c8b822e9e89ccc2b8552ca294wangyxdeMBP:~ wangyx$ shasum -a 1 test.txt1367a1ab1da100436c5ea6b0dc0d737ada6aede4 test.txtwangyxdeMBP:~ wangyx$ shasum -a 256 test.txt5913f04a2a92cbd0346a4a7cf7856f8174e12657ca267764b57da90b27c4c51f test.txt 我们可以使用计算出的校验值和网站提供的校验值对比，可以看出文件是否被篡改。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酸酸乳]]></title>
    <url>%2F2018%2F05%2Fvultr-ssr%2F</url>
    <content type="text"><![CDATA[1. 首先官网注册账号点我注册账号 2. 充值Vultr 支持支付宝及 PayPal 和信用卡支付。 3. 选择属性 地区 选择操作系统（建议 Centos6） 选择配置 额外选项（根据需要自定义） 等待安装 4. 登录 VPS 获得 IP 及密码，登录远程 VPS 安装脚本（逗比提供） wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 按提示操作 最后可以使用 SSR 客户端进行连接测试。]]></content>
      <categories>
        <category>实用</category>
      </categories>
      <tags>
        <tag>Vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装锐速破解版或 Google BBR 魔改版]]></title>
    <url>%2F2018%2F05%2Fvps-install-server-speeder%2F</url>
    <content type="text"><![CDATA[注意：安装锐速需降级系统内核，而安装 Google BBR 算法需要升级系统内核，二者不可同时安装（本文以CentOS6 64位为例） 安装锐速（ServerSpeeder）破解版1. 查看系统内核版本输入 $ uname -r 查看当前系统内核版本（如果安装时选的 CentOS6 64 位系统的话，会出现以下文字） 2. 获取并执行安装脚本执行以下命令：wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install &#39;2.6.32-642.el6.x86_64&#39; 一路回车即可出现以下内容即为安装成功 另附 CentOS7 安装锐速破解版命令： 更换内核 wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh &amp;&amp; bash rskernel.sh重启后执行安装 yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install 安装 Google BBR 魔改版CentOS6/7 使用 输入以下命令： wget --no-check-certificate https://raw.githubusercontent.com/nanqinlang-tcp/tcp_nanqinlang/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.sh &amp;&amp; bash tcp_nanqinlang-1.3.2.sh 如内核过低，需要先升级内核，再安装算法。 安装成功后会出现以下界面： 参考地址：地址1 地址2]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 整合 Redis 的序列化]]></title>
    <url>%2F2018%2F04%2Fspring-redis%2F</url>
    <content type="text"><![CDATA[序列化策略 String 序列化StringRedisTemplate 默认采用的是 String 的序列化策略，保存的 key 和 value 都是采用此策略序列化保存的。即 StringRedisSerializer JDK 序列化RedisTemplate 默认采用的是 JDK 的序列化策略，保存的 key 和 value 都是采用此策略序列化保存的。即 JdkSerializationRedisSerializer JacksonJsonRedisSerializer Jackson2JsonRedisSerializer OxmSerializer 可能遇到的问题 因为序列化策略的不同，即使是同一个 key 用不同的 Template 去序列化，结果是不同的。所以根据 key 去进行操作 Redis 中的数据时，就会出现各种操作失败的问题。 解决方案可以手动指定 RedisTemplate 的 key 的序列化策略 12345678910&lt;!-- redis 序列化策略 ，通常情况下key值采用String序列化策略， --&gt; &lt;!-- 如果不指定序列化策略，StringRedisTemplate的key和value都将采用String序列化策略； --&gt; &lt;!-- 但是RedisTemplate的key和value都将采用JDK序列化 这样就会出现采用不同template保存的数据不能用同一个template操作的问题 --&gt; &lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;bean id='redisWriteTemplate' class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisWriteConnectionFactory" /&gt; &lt;property name="keySerializer" ref="stringRedisSerializer" /&gt; &lt;property name="hashKeySerializer" ref="stringRedisSerializer" /&gt; &lt;/bean&gt; 总结推荐将所有 Template 的 key 都采用 String 的序列化方式，而 value 的序列化方式可以采用不同的序列化方式。（jedis 自动选择）(这样还有一个好处就是不必 string 的也采用 jdk 的序列化从而导常用数据格式致为了存储数据结构浪费空间) 参考地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号网页授权]]></title>
    <url>%2F2018%2F04%2Fwechat-userinfo%2F</url>
    <content type="text"><![CDATA[起因 之前写过一个接口，配合前端在微信内的 H5 页面获取用户信息，之前为了省事，酿成上线当晚疯狂改代码的惨祸。 本来很简单的接口，只需要完全按照官方 API 开发即可，但是，我想秀一把骚操作，事实证明这完全是错误的思路。 错误示例😂 官方网页获取用户信息步骤： 补充一句：第一步中所说的需要引导用户同意授权，之前肯定是没有这句的（欢迎打脸） 其中，第二步其实就可以获取到用户的 openid，但是： 这里可以获取到 openid，然后： 微信提供的这个接口可以直接获取到用户信息，并且有我最想要的 unionid，于是毫不犹豫的就是用上一步获取到的 openid 去获取用户信息了， 结果必须用户关注后才能获取到，开始是测试号，以为不是正式环境，所以才得关注，就没在意。 结果 上到生产环境后，未关注公众号的微信号打开网页后，利用公众号做的异常通知模板推送一直推消息报错 code 获取 access_token 顺便获取到 openid 是没错的 12&#123;"access_token":"8_gmDP6FclzBab_kfY3t5pL7SNfWItCykr90BwhxrD0BJ8m7vHQkevqaL0H10GMg_tL340F0PT91VaQoLnGkLHdMTsLDpB165gByGbJie-ZkQ","expires_in":7200,"refresh_token":"8_9c3mYLWv6T_Emsdq2rydo2h9uBHY9RbEBQsjr4IwTdihvx6lA842tDZM4-WdftOSBMLIsN40C3kRT9X3QydF0AQq8jh876slOH83iMXGnvI","openid":"osyqutx1SsYKZDhwuHe5HoR_B72I","scope":"snsapi_base"&#125; 之后用获取到的 openid 调通用接口获取用户信息报错，具体内容记不清了，大致是提示用户未关注公众号。 失败告终 正确方法 小心驶得万年船]]></content>
      <categories>
        <category>日常踩坑</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Music!]]></title>
    <url>%2F2018%2F04%2Fhello-music%2F</url>
    <content type="text"><![CDATA[Welcome to my music world! I’m still working on this page, but it’ll be on-line soon!]]></content>
      <categories>
        <category>Music</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)基本使用]]></title>
    <url>%2F2018%2F03%2Fgitee-usage%2F</url>
    <content type="text"><![CDATA[概要使用 GitHub 时，经常遇到速度慢甚至无法连接的情况（Wall），而且 GitHub 创建私有仓库是需要收费的，有以上需求的可以考虑使用国内的 Git 托管服务 码云。 相比于 GitHub ，码云有以下优势： 首先，在语言的使用上，当然中文交流更畅快、更有效率； 其次，国内 IT 行业有自己的特点，天然决定了对开源软件的需求也有自己的特点，比如小程序这个东西，只有国内有，做个开源的小程序托管在码云比 GitHub 明显更有优势，因为关注着都是国内的开发者； 然后，开源不仅仅是大项目，像 OpenStack、Tensorflow 这样的大厂大作，确实有 GitHub 就够了，但是这样的大型项目毕竟不是普遍情况。现在编程越来越普及，每个人都可以参与和贡献开源项目，去做一些有意思的东西分享出来，那么从受众、交流便利度、访问速度等方面，码云都有优势。 配置公钥macOS 下运行 $ ssh-keygen -t rsa -C &quot;XXXXX&quot; 将生成的公钥内容按照如下方式配置到个人码云上： 新建项目 配置远程库关联首先执行： $ git remote -v 查看本地关联的远程库，如果没有任何关联，可以执行$ git remote add gitee git@gitee.com:trymesoft/myblog.git添加远程库。 如果存在说明当前目录之前关联过 Git 远程库，可以在一个新的目录执行$ git init初始化一个新的本地仓库，也可以执行$ git remove rm &quot;XXX&quot;删除，还可以再添加一个不重名的远程库。 提交的时候指定 push，例：$ git push gitee master这样一来，我们的本地库就可以同时与多个远程库互相同步： 参考：地址1 地址2 2018-05-06更新 有的时候，我们按上述过程配置完成后，执行$ ssh -T v git@gitee.com时，会出现以下错误： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798OpenSSH_7.4p1, LibreSSL 2.5.0debug1: Reading configuration data /etc/ssh/ssh_configdebug1: Connecting to gitee.com [120.55.226.24] port 22.debug1: Connection established.debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_rsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_rsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_dsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_dsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_ecdsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_ecdsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_ed25519 type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/wangyx/.ssh/id_ed25519-cert type -1debug1: Enabling compatibility mode for protocol 2.0debug1: Local version string SSH-2.0-OpenSSH_7.4debug1: Remote protocol version 2.0, remote software version OSChina.NETdebug1: no match: OSChina.NETdebug1: Authenticating to gitee.com:22 as &apos;git&apos;debug1: SSH2_MSG_KEXINIT sentdebug1: SSH2_MSG_KEXINIT receiveddebug1: kex: algorithm: curve25519-sha256@libssh.orgdebug1: kex: host key algorithm: ecdsa-sha2-nistp256debug1: kex: server-&gt;client cipher: aes128-ctr MAC: hmac-sha2-256 compression: nonedebug1: kex: client-&gt;server cipher: aes128-ctr MAC: hmac-sha2-256 compression: nonedebug1: expecting SSH2_MSG_KEX_ECDH_REPLYdebug1: Server host key: ecdsa-sha2-nistp256 SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wcdebug1: Host &apos;gitee.com&apos; is known and matches the ECDSA host key.debug1: Found key in /Users/wangyx/.ssh/known_hosts:1debug1: rekey after 4294967296 blocksdebug1: SSH2_MSG_NEWKEYS sentdebug1: expecting SSH2_MSG_NEWKEYSdebug1: SSH2_MSG_NEWKEYS receiveddebug1: rekey after 4294967296 blocksdebug1: SSH2_MSG_SERVICE_ACCEPT receiveddebug1: Authentications that can continue: publickeydebug1: Next authentication method: publickeydebug1: Trying private key: /Users/wangyx/.ssh/id_rsadebug1: Trying private key: /Users/wangyx/.ssh/id_dsadebug1: Trying private key: /Users/wangyx/.ssh/id_ecdsadebug1: Trying private key: /Users/wangyx/.ssh/id_ed25519debug1: No more authentication methods to try.Permission denied (publickey). 解决方法 执行ssh-add 文件绝对路径即可。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK1.5-JDK1.8 新特性]]></title>
    <url>%2F2018%2F03%2Fjdk1.5-1.8features%2F</url>
    <content type="text"><![CDATA[本篇文章记录JDK1.5版本到JDK1.7版本的新特性及JDK1.8主要部分特性。 JDK1.5新特性1. 自动装箱与拆箱 自动装箱：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。自动拆箱：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。自动拆箱，只需将该对象值赋给一个基本类型即可。类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean 2. 枚举 把集合里的对象元素一个个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。简单用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。 3. 静态导入 通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner;后者一般是导入静态的方法，import static java.lang.System.out。 4. 可变参数（Varargs） 可变参数的简单语法格式为：methodName([argumentList], dataType... argumentName); 5. 内省（Introspector） 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通过这些API可以使你不需要了解这个规则（但最好还是要搞清楚），这些API存放于包java.beans中。 6. 泛型(Generic) C++ 通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样可以得到强类型在编译时刻进行类型检查的好处。 7. For-Each循环 For-Each循环得加入简化了集合的遍历。 JDK1.6新特性1. Desktop类和SystemTray类 在JDK6中 ,AWT新增加了两个类:Desktop和SystemTray。 前者可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件（比如：用记事本打开以txt为后缀名的文件）， 用系统默认的打印机打印文档；后者可以用来在系统托盘区创建一个托盘程序。 2. 使用JAXB2来实现对象与XML之间的映射 JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。 我们把对象与关系数据库之间的映射称为ORM，其实也可以把对象与XML之间的映射称为OXM（Object XML Mapping） 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0，比起1.0(JSR 31)来， JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。 实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。 除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。 3. 理解StAX StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 StAX的来历：在JAXP1.3(JSR 206)有两种处理XML文档的方法：DOM(Document Object Model)和SAX(Simple API for XML)。 由于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4 (JAXP1.4是JAXP1.3的维护版本)。 JDK6里面JAXP的版本就是1.4。 StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程，程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件， 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符 SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个 xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4. 使用Compiler API 现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。 5. 轻量级Http Server API JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. 6. 插入式注解处理API(Pluggable Annotation Processing API) 插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)实际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type,variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理. 如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。 7. 用Console开发控制台程序 JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. 8. 对脚本语言的支持如: ruby, groovy, javascript9. Common Annotations Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务,如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性. 下面列举出Common Annotations 1.0里面的10个Annotations Common Annotations Annotation Retention Target Description Generated Source ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE 用于标注生成的源代码 Resource Runtime TYPE, METHOD, FIELD 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入 PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的。RolesAllowed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的 PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法 DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行 DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色 注意: RolesAllowed,PermitAll,DenyAll不能同时应用到一个类或方法上 标注在方法上的RolesAllowed,PermitAll,DenyAll会覆盖标注在类上的RolesAllowed,PermitAll,DenyAll RunAs,RolesAllowed,PermitAll,DenyAll和DeclareRoles还没有加到Java SE 6.0上来 处理以上Annotations的工作是由Java EE容器来做, Java SE 6.0只是包含了上面表格的前五种Annotations的定义类,并没有包含处理这些Annotations的引擎,这个工作可以由Pluggable Annotation Processing API(JSR 269)来做改动的地方最大的就是java GUI界面的显示了，JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持！！！你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果. JDK 1.7新特性1. switch中可以使用字串1234567891011String s = "test";switch (s) &#123; case "test" : System.out.println("test");case "test1" : System.out.println("test1");break ;default : System.out.println("break");break ;&#125; 2. “&lt;&gt;”的运用List tempList = new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断。123456789101112131415161718192021222324252627public class JDK7GenericTest &#123; public static void main(String[] args) &#123; // Pre-JDK 7 List&lt;String&gt; lst1 = new ArrayList&lt;String&gt;(); // JDK 7 supports limited type inference for generic instance creation List&lt;String&gt; lst2 = new ArrayList&lt;&gt;(); lst1.add("Mon"); lst1.add("Tue"); lst2.add("Wed"); lst2.add("Thu"); for (String item: lst1) &#123; System.out.println(item); &#125; for (String item: lst2) &#123; System.out.println(item); &#125; &#125;&#125; 3. 自定义自动关闭类以下是jdk7 api中的接口，（不过注释太长，删掉了close()方法的一部分注释）123456789101112131415/** * A resource that must be closed when it is no longer needed. * * @author Josh Bloch * @since 1.7 */public interface AutoCloseable &#123; /** * Closes this resource, relinquishing any underlying resources. * This method is invoked automatically on objects managed by the * &#123;@code try&#125;-with-resources statement. * */ void close() throws Exception;&#125; 只要实现该接口，在该类对象销毁时自动调用close方法，你可以在close方法关闭你想关闭的资源，例子如下12345678910111213141516171819class TryClose implements AutoCloseable &#123; @Override public void close() throws Exception &#123; System.out.println(" Custom close method … close resources "); &#125;&#125;//请看jdk自带类BufferedReader如何实现close方法（当然还有很多类似类型的类） public void close() throws IOException &#123; synchronized (lock) &#123; if (in == null) return; in.close(); in = null; cb = null; &#125; &#125; 4. 新增一些取环境信息的工具方法123456789File System.getJavaIoTempDir() // IO临时文件夹File System.getJavaHomeDir() // JRE的安装目录File System.getUserHomeDir() // 当前用户目录File System.getUserDir() // 启动java进程时所在的目录....... 5. Boolean类型反转，空指针安全，参与位运算123456789101112131415Boolean Booleans.negate(Boolean booleanObj)True =&gt; False , False =&gt; True, Null =&gt; Nullboolean Booleans.and(boolean[] array)boolean Booleans.or(boolean[] array)boolean Booleans.xor(boolean[] array)boolean Booleans.and(Boolean[] array)boolean Booleans.or(Boolean[] array)boolean Booleans.xor(Boolean[] array) 6. 两个char间的equals1boolean Character.equalsIgnoreCase(char ch1, char ch2) 7. 安全的加减乘除1234567891011121314151617181920212223int Math.safeToInt(long value)int Math.safeNegate(int value)long Math.safeSubtract(long value1, int value2)long Math.safeSubtract(long value1, long value2)int Math.safeMultiply(int value1, int value2)long Math.safeMultiply(long value1, int value2)long Math.safeMultiply(long value1, long value2)long Math.safeNegate(long value)int Math.safeAdd(int value1, int value2)long Math.safeAdd(long value1, int value2)long Math.safeAdd(long value1, long value2)int Math.safeSubtract(int value1, int value2) 8. 对Java集合（Collections）的增强支持 在JDK1.7之前的版本中，Java集合容器中存取元素的形式如下：以List、Set、Map集合容器为例：1234567891011121314151617//创建List接口对象List&lt;String&gt; list=new ArrayList&lt;String&gt;();list.add("item"); //用add()方法获取对象String Item=list.get(0); //用get()方法获取对象 //创建Set接口对象Set&lt;String&gt; set=new HashSet&lt;String&gt;();set.add("item"); //用add()方法添加对象 //创建Map接口对象Map&lt;String,Integer&gt; map=new HashMap&lt;String,Integer&gt;();map.put("key",1); //用put()方法添加对象int value=map.get("key"); 在JDK1.7中，摒弃了Java集合接口的实现类，如：ArrayList、HashSet和HashMap。而是直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象，如下：12345List&lt;String&gt; list=["item"]; //向List集合中添加元素String item=list[0]; //从List集合中获取元素Set&lt;String&gt; set=&#123;"item"&#125;; //向Set集合对象中添加元素Map&lt;String,Integer&gt; map=&#123;"key":1&#125;; //向Map集合中添加对象int value=map["key"]; //从Map集合中获取对象 9. 数值可加下划线1int one_million = 1_000_000; 10. 支持二进制文字1int binary = 0b1001_1001; 11. 简化了可变参数方法的调用 当程序员试图使用一个不可具体化的可变参数并调用一个varargs （可变）方法时，编辑器会生成一个“非安全操作”的警告。 12. 在try catch异常捕捉中，一个catch可以写多个异常类型，用”|”隔开jdk7之前：1234567try &#123; ......&#125; catch(ClassNotFoundException ex) &#123; ex.printStackTrace();&#125; catch(SQLException ex) &#123; ex.printStackTrace();&#125; jdk7例:12345try &#123; ......&#125; catch(ClassNotFoundException|SQLException ex) &#123; ex.printStackTrace();&#125; 13. jdk7之前，你必须用try{}finally{}在try内使用资源，在finally中关闭资源，不管try中的代码是否正常退出或者异常退出。jdk7之后，你可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源jdk7之前：123456789101112131415161718192021222324252627282930313233import java.io.*;// Copy from one file to another file character by character.// Pre-JDK 7 requires you to close the resources using a finally block.public class FileCopyPreJDK7 &#123; public static void main(String[] args) &#123; BufferedReader in = null; BufferedWriter out = null; try &#123; in = new BufferedReader(new FileReader("in.txt")); out = new BufferedWriter(new FileWriter("out.txt")); int charRead; while ((charRead = in.read()) != -1) &#123; System.out.printf("%c ", (char)charRead); out.write(charRead); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; finally &#123; // always close the streams try &#123; if (in != null) in.close(); if (out != null) out.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; try &#123; in.read(); // Trigger IOException: Stream closed &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; jdk7之后：123456789101112131415161718import java.io.*;// Copy from one file to another file character by character.// JDK 7 has a try-with-resources statement, which ensures that// each resource opened in try() is closed at the end of the statement.public class FileCopyJDK7 &#123; public static void main(String[] args) &#123; try (BufferedReader in = new BufferedReader(new FileReader("in.txt")); BufferedWriter out = new BufferedWriter(new FileWriter("out.txt"))) &#123; int charRead; while ((charRead = in.read()) != -1) &#123; System.out.printf("%c ", (char)charRead); out.write(charRead); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; JDK1.8 十大新特性1. 接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法123456interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。12345678Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java8的这个特新在编译器实现的角度上来说更加接近Scala的trait。在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java8的这个在语义上有差别。 2. Lambda 表达式首先看看在老版本的Java中是如何排列字符串的：1234567List&lt;String&gt; names = Arrays.asList("peter", "anna", "mike", "xenia");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 只需要给静态方法Collections.sort传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java8提供了更简洁的语法，lambda表达式：123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 代码变得更段且更具有可读性，但是实际上还可以写得更短：1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); ava编译器可以自动推导出参数类型，所以你可以不用再写一次类型。 3. 函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。示例如下：1234567@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert("123");System.out.println(converted); // 123 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。注： 将lambda表达式映射到一个单方法的接口上，这种做法在Java8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget的addEventListener第二个参数EventListener。 4. 方法与构造函数引用前一节中的代码还可以通过静态方法引用来表示：123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert("123");System.out.println(converted); // 123 Java8允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：123converter = something::startsWith;String converted = converter.convert("Java");System.out.println(converted); // "J" 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：12345678910class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来我们指定一个用来创建Person对象的对象工厂接口：123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create("Peter", "Parker"); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5. Lambda 作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6. 访问局部变量可以直接在lambda表达式中访问外层的局部变量：1234final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：1234int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：1234int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3; 在lambda表达式中试图修改num同样是不允许的。 7. 访问对象字段与静态变量和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：123456789101112131415class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 8. 访问接口的默认方法还记得之前的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：12Formula formula = (a) -&gt; sqrt( a * 100);Built-in Functional Interfaces JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：123456789Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test("foo"); // truepredicate.negate().test("foo"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：123Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply("123"); // "123" Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumer 接口表示执行在单个参数上的操作。12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello, " + p.firstName);greeter.accept(new Person("Luke", "Skywalker")); Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法123456Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person("John", "Doe");Person p2 = new Person("Alice", "Wonderland");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。123456Optional&lt;String&gt; optional = Optional.of("bam");optional.isPresent(); // trueoptional.get(); // "bam"optional.orElse("fallback"); // "bam"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // "b" Stream 接口 java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。 首先看看Stream是怎么用，首先创建实例代码的用到的数据List：123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add("ddd2");stringCollection.add("aaa2");stringCollection.add("bbb1");stringCollection.add("aaa1");stringCollection.add("bbb3");stringCollection.add("ccc");stringCollection.add("bbb2");stringCollection.add("ddd1"); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。 Filter 过滤过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作 （比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行 其他Stream操作。12345stringCollection .stream() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);// "aaa2", "aaa1" Sort 排序排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。123456stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith("a")) .forEach(System.out::println);// "aaa1", "aaa2" 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的12System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。123456stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1" Match 匹配 Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。12345678910111213141516171819boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith("a"));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith("a"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith("z"));System.out.println(noneStartsWithZ); // true Count 计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。123456long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith("b")) .count();System.out.println(startsWithB); // 3 Reduce 规约这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：1234567Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + "#" + s2);reduced.ifPresent(System.out::println);// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2" 并行Streams 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 下面的例子展示了是如何通过并行Stream来提升性能： 首先我们创建一个没有重复元素的大表：123456int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 然后我们计算一下排序这个Stream要耗时多久，串行排序：123456789long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("sequential sort took: %d ms", millis));// 串行耗时: 899 ms 并行排序：12345678910long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format("parallel sort took: %d ms", millis));// 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 MapMap类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。12345Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, "val" + i);&#125;map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。下面的例子展示了map上的其他有用的函数：12345678910map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; "val" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; "bam");map.get(3); // val33 接下来展示如何在Map里删除一个键值全都匹配的项：1234map.remove(3, "val3");map.get(3); // val33map.remove(3, "val33");map.get(3); // null 另外一个有用的方法：1map.getOrDefault(42, "not found"); // not found 对Map的元素做合并也变得很容易了：1234map.merge(9, "val9", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9map.merge(9, "concat", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9concat Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 9. Date APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：Clock 时钟 Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。1234Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。12345678System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of("Europe/Berlin");ZoneId zone2 = ZoneId.of("Brazil/East");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：123456789LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。123456789LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);System.out.println(leetTime); // 13:37 LocalDate 本地日期LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。12345678LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：123456DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTime 本地日期时间LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。123456789LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。12345Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：123456DateTimeFormatter formatter = DateTimeFormatter .ofPattern("MMM dd, yyyy - HH:mm");LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html 10. Annotation 注解在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解：1234567@interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法）12@Hints(&#123;@Hint("hint1"), @Hint("hint2")&#125;)class Person &#123;&#125; 例 2：使用多重注解（新方法）123@Hint("hint1")@Hint("hint2")class Person &#123;&#125; 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：123456Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。另外Java 8的注解还增加到两种新的target上了：12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125; 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 参考： 点我]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web3.js 调用已部署智能合约的 function]]></title>
    <url>%2F2018%2F03%2Fethereum-web3js%2F</url>
    <content type="text"><![CDATA[简介与环境简介 web3.js 是以太坊提供的一个 JavaScript 库，它封装了以太坊的 JSON RPC API、IPC 调用，提供了一系列与以太坊区块链交互的对象和函数。几乎囊括 JSON RPC 的 API，还可以编译和部署智能合约以及调用智能合约等，其中最重要的就是与智能合约交互的 JS 对象及函数。 开发环境 macOS 操作系统 Node.js 8.9.4 npm 5.6.0 调用智能合约首先需要使用 Solidity 编写智能合约，最简单的合约如下，不与区块发生联系： 1234567891011pragma solidity ^0.4.2; contract hello &#123; function hello() public &#123; &#125; function say() constant public returns (string) &#123; return &quot;Hello World!&quot;; &#125; &#125; 注：Solidity 在线编译环境 地址 编译后会产生很多不同的东西，部分如下： WEB3DEPLOY： 123456789101112var helloContract = web3.eth.contract([&#123;"constant":true,"inputs":[],"name":"say","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"type":"function","stateMutability":"view"&#125;,&#123;"inputs":[],"payable":false,"type":"constructor","stateMutability":"nonpayable"&#125;]);var hello = helloContract.new( &#123; from: web3.eth.accounts[0], data: '0x6060604052341561000c57fe5b5b5b5b6101598061001e6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063954ab4b21461003b575bfe5b341561004357fe5b61004b6100d4565b604051808060200182810382528381815181526020019150805190602001908083836000831461009a575b80518252602083111561009a57602082019150602081019050602083039250610076565b505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc610119565b604060405190810160405280600c81526020017f48656c6c6f20576f726c6421000000000000000000000000000000000000000081525090505b90565b6020604051908101604052806000815250905600a165627a7a72305820b88ade0e1b40d9f8ffeba3f2bc9aa2ee4a1ae17f03fc52fc568812eb5d96f5ad0029', gas: '4700000' &#125;, function (e, contract)&#123; console.log(e, contract); if (typeof contract.address !== 'undefined') &#123; console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); &#125; &#125;) ABI（后面会用到）： 12345678910111213141516171819202122[ &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;say&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; &#125; ], &quot;payable&quot;: false, &quot;type&quot;: &quot;function&quot;, &quot;stateMutability&quot;: &quot;view&quot; &#125;, &#123; &quot;inputs&quot;: [], &quot;payable&quot;: false, &quot;type&quot;: &quot;constructor&quot;, &quot;stateMutability&quot;: &quot;nonpayable&quot; &#125;] 创建一个 test.js，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940// 引入依赖模块var express = require("express")var Web3 = require("web3")var net = require("net")var http = require("http")var web3;// 创建web3对象并连接到以太坊节点if (typeof web3 !== 'undefined') &#123; web3 = new Web3(web3.currentProvider);&#125; else &#123; // set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider("http://192.168.53.60:8545"));&#125;// 合约ABIvar abi = [&#123;"constant":true,"inputs":[],"name":"say","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"stateMutability":"view","type":"function"&#125;,&#123;"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"&#125;];// 合约地址var address = "0xf77976c9a552f2934d3694c38fbd057ae803ef45";// 通过ABI和地址获取已部署的合约对象var helloContract = new web3.eth.Contract(abi,address);http.createServer(function (request, response) &#123; // 调用智能合约方法 var helloResult = helloContract.methods.say().call().then(function(result)&#123; console.log("返回值:" + result); // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 response.end(result);&#125;); &#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 启动之前应该先加载 test.js 所依赖的模块： 123$ npm install express $ npm install web3 $ npm install http 运行 1$ node test.js 终端打印出”Server running at http://127.0.0.1:8888&quot;时即可访问&quot;http://127.0.0.1:8888&quot;，网页会返回&quot;Hello World”！]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>Web3.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 安装 Jenkins]]></title>
    <url>%2F2018%2F02%2Fcentos-jenkins-install%2F</url>
    <content type="text"><![CDATA[下载下载 Jenkins 的 war 包，地址 新的 Jenkins 的 war 包需要 JDK1.8 的支持，如果想在 JDK1.7 的环境下使用，可以下载 Jenkins2.19.3 的包 点击如上链接可以进入选择旧版本的 war 包进行下载。 启动可将 Jenkins 直接放到 Tomcat 容器中，启动 Tomcat 容器即可自动部署，启动时会生成一个默认密码如下： 此时可以直接访问了，第一次访问 Jenkins 会自动下载一些东西，等待片刻即可： 此时可以访问 Jenkins 页面，输入启动时控制台打印的随机密码即可： 开始使用输入完密码后出现如下页面： 可根据个人使用习惯选择安装建议的插件或者自定义安装插件，后续仍可在插件管理中管理插件，这里我选择第一个。自动安装一些插件，安装完成后页面： 进入后，选择性的安装插件即可使用！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int 类型过大变成负数]]></title>
    <url>%2F2017%2F09%2Frecord-int%2F</url>
    <content type="text"><![CDATA[计算机存储系统使用补码标识，int 类型占 32 位，首位是符号位：0 表示正数，1 表示负数。正数补码与原码相同负数补码除符号位其余各位与原码取反，然后加 1 日常开发中常用的方法我们一般会抽取出公用的方法，想使用一个操作日期的工具类，本来想用 Apache 的 commons 包的 DateUtils 工具类，但是没有找到想要的方法，转而求其次使用之前同事封装的工具类，结果遇到一个问题。 需求：给定一个 Date 对象，找到特定天数后的日期时间 工具类代码如下：1234public static Date datetimeAddDay(Date datetime, int day) &#123; datetime.setTime(datetime.getTime() + day * 24 * 60 * 60 * 1000); return datetime;&#125; 猛的一看，并没有什么不对，结果运行时日期不对，写个测试类跑了一下，大吃一惊！！！测试类代码：1234567@Testpublic void testDatetimeAddDay() &#123; Date datetime = new Date(); System.out.println("当前时间：" + datetime); Date datetimeAddDay = DateUtil.datetimeAddDay(datetime, 30); System.out.println("30天后：" + datetimeAddDay);&#125; 运行结果： 这时间还给我倒回去了，原来是工具类的方法加的毫秒数超过 int 类型最大值了 2的31次方-1，符号位成了 1，整体变为负数。所以工具类中运算的毫秒数使用 long 类型即可！]]></content>
      <categories>
        <category>日常踩坑</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.3(64位)安装 MySQL5.7]]></title>
    <url>%2F2017%2F09%2Fcentos-mysql-install%2F</url>
    <content type="text"><![CDATA[CentOS 下安装 MySQL 比较麻烦，每一步都有坑，还是记下来比较好 O(∩_∩)O哈哈~ 1. 下载安装包官网 下载文件。 选择系统版本 勾选如下选项下载： 2. 上传服务器并解压注： CentOS7 预装 MariaDB，可能有冲突，先卸载12$ rpm -qa |grep -i mariadb $ rpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64` 再执行解压： $ tar -xvf mysql-5.7.19-1.el7.x86_64.rpm-bundle.tar 3. 开始安装执行以下命令： 1234567891011$ rpm -ivh mysql-community-common-5.7.19-1.el7.x86_64.rpm$ rpm -ivh mysql-community-libs-5.7.19-1.el7.x86_64.rpm$ rpm -ivh mysql-community-libs-compat-5.7.19-1.el7.x86_64.rpm $ rpm -ivh mysql-community-client-5.7.19-1.el7.x86_64.rpm$ rpm -ivh mysql-community-server-5.7.19-1.el7.x86_64.rpm$ rpm -ivh mysql-community-devel-5.7.19-1.el7.x86_64.rpm 倒数第二步可能会报如下错误： 原因：缺少 libaio 库 解决方案：安装 libaio 库 点我 1$ rpm -ivh libaio-0.3.107-10.el6.x86_64.rpm 4. 启动 MySQL 服务并设置开机启动12345systemctl start mysqldsystemctl enable mysqldsystemctl daemon-reload 5. 根据临时密码登录 MySQL$ vi /var/log/mysqld.log 6. 修改密码登录后必须修改密码，不然无法执行 SQL 语句，会报如下错误： ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 当执行 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;wang123&#39;; 修改密码时又会报一下错误： ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 这个错误与 validate_password_policy 密码策略有关，执行以下代码修改策略，此时只会基于长度判断： $ set global validate_password_policy=0;太复杂了，😭 未完，待续！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 整合 AspectJ 的 AOP 处理异常]]></title>
    <url>%2F2017%2F08%2Fspring-aop-exception%2F</url>
    <content type="text"><![CDATA[注：本文只介绍如何处理异常通知 工作需要，之前的项目上线后，基本是靠运维查看并发现运行中的异常。新的项目启动一段时间了，单纯的靠运维人工发现程序运行中的异常效率低下，可以利用 Spring 的 AOP（Aspect Oriented Programming面向切面编程）来实现自动捕获项目中发生的异常。 1. 创建一个 Maven 项目，配置 pom 文件，引入相关依赖 jar 包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;3.2.4.RELEASE&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 创建目标 target，即需要被增强的类123456789101112import net.okdi.core.service.PromoService;import org.springframework.stereotype.Service;@Servicepublic class PromoServiceImpl implements PromoService &#123; public String insertRecord(String memberId) &#123; System.out.println("开始添加记录。。。"); int i = 1 / 0; // 除0异常 System.out.println("添加记录完毕。。。"); return null; &#125;&#125; 3. 创建通知（即增强类 advice）1234567891011121314151617package net.okdi.core.exception;import org.aspectj.lang.JoinPoint;/** * 异常通知增强 */public class ExceptionHelper &#123; public void afterThrow(JoinPoint jp, Throwable ex) &#123; System.out.println("************************"); // 程序运行抛出异常后的业务处理... System.out.println("正常业务处理"); System.out.println(ex.getMessage()); System.out.println("************************"); &#125;&#125; 在 aspectj 框架中它的增强可以不实现任何接口，只需要定义出增强功能(方法)。两个参数 JoinPoint 和 Exception。JoinPoint 是切点，它的 getArgs() 方法可以获取传入的参数；getSignature() 方法返回一个 Signature 对象，这个对象的 getDeclaringTypeName() 方法可以获取异常发生的类的全路径，getName() 方法可以获取抛出异常的方法。 4. 在 Spring 的 xml 配置文件中配置（或者使用 @AfterThrowing 注解配置）123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 注解扫描包 --&gt; &lt;context:component-scan base-package="net.okdi"/&gt; &lt;!-- 配置目标 --&gt; &lt;bean id="promoService" class="net.okdi.core.service.impl.PromoServiceImpl"/&gt; &lt;!-- 配置通知 --&gt; &lt;bean id="exceptionAdvice" class="net.okdi.core.exception.ExceptionHelper"/&gt; &lt;!-- aop:config声明，aop:aspect配置切面 proxy-target-class默认false（有接口jdk动态代理，无接口cglib动态代理）true强制cglib代理 --&gt; &lt;aop:config proxy-target-class="true"&gt; &lt;aop:aspect ref="exceptionAdvice"&gt; &lt;aop:after-throwing method="afterThrow" pointcut="execution(* net.okdi.core..*(..))" throwing="ex"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; proxy-target-class 默认false（有接口 jdk 动态代理，无接口 cglib 动态代理）修改为 true 强制使用 cglib 动态代理。 5. 编写测试类进行测试123456789101112131415161718import net.okdi.core.service.PromoService;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:applicationContext.xml"&#125;)public class Test &#123; @Autowired private PromoService promoService; @org.junit.Test public void test() &#123; promoService.insertRecord(""); &#125;&#125; 6. 测试结果至此，利用 Spring 整合 AspectJ 框架进行 AOP 中的异常通知处理开发完毕！]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Maven</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 新建 Maven 项目]]></title>
    <url>%2F2017%2F08%2Fidea-maven%2F</url>
    <content type="text"><![CDATA[从 MyEclipse 转 IntelliJ IDEA（以下简称IDEA）已经有一段时间了，深深体会到一个强大的 IDE 对开发者来说是多么的重要，IDEA 拥有强大的快捷键及酷炫的界面风格，花了点时间勉强能上手开发，在此记录一下Maven项目的创建。 1. 创建新项目，并勾选以下选项 2. 填写 GroupId 和 ArtifactId GroupId：定义了项目属于哪个组，一般来说这个通常和公司或组织关联；ArtifactId：定义了当前 Maven 项目在组中的唯一 id。 3. 配置 Maven（可以略过，创建完项目再进行更改） 4. 项目创建完成后，每次配置 pom 文件都要刷新 Maven 依赖 至此，一个新的基于 Maven 管理依赖 JAR 包的 Web 项目创建完毕！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 概念]]></title>
    <url>%2F2017%2F04%2Frabbitmq-started%2F</url>
    <content type="text"><![CDATA[消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，也可以把它用于系统间服务的相互调用（RPC）。 RabbitMQ 简介 AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ 是一个开源的 AMQP 实现，服务器端用 Erlang 语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 常用 API 对象 ConnectionFactory、Connection、Channel 都是 RabbitMQ 对外提供的 API 中最基本的对象。Connection 是 RabbitMQ 的 socket 链接，它封装了 socket 协议相关部分逻辑。ConnectionFactory 为 Connection 的制造工厂。Channel 是我们与 RabbitMQ 打交道的最重要的一个接口，我们大部分的业务操作是在 Channel 这个接口中完成的，包括定义 Queue、定义 Exchange、绑定 Queue 与 Exchange、发布消息等。 Queue Queue（队列）是 RabbitMQ 的内部对象，用于存储消息 RabbitMQ 中的消息都只能存储在 Queue 中，生产者（P）生产消息并最终（中间会经过交换器）投递到 Queue 中，消费者（C）可以从 Queue 中获取消息并消费。 多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 消息回执（Message acknowledgment） 在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给 RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从 Queue 中移除；如果 RabbitMQ 没有收到回执并检测到消费者的 RabbitMQ 连接断开，则 RabbitMQ 会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在 timeout 概念， 一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的 RabbitMQ 连接断开。 这里会产生另外一个问题，如果开发人员在处理完业务逻辑后，忘记发送回执给 RabbitMQ，这将会导致严重的 bug——Queue 中堆积的消息会越来越多，消费者重启后会重复消费这些消息并重复执行业务逻辑… 另外 publish message（发送消息）是没有 ack 的。 消息持久化（Message durability） 如果我们希望即使在 RabbitMQ 服务重启的情况下，也不会丢失消息，我们可以将 Queue 与 Message 都设置为可持久化的（durable）, 这样可以保证绝大部分情况下我们的 RabbitMQ 消息不会丢失。但依然解决不了小概率丢失事件的发生（比如 RabbitMQ 服务器已经接收到生产者的消息，但还没来得及持久化该消息时 RabbitMQ 服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。 Prefetch count 如果有多个消费者同时订阅同一个 Queue 中的消息，Queue 中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置 prefetchCount 来限制 Queue 每次发送给每个消费者的消息数，比如我们设置 prefetchCount=1，则 Queue 每次给每个消费者发送一条消息；消费者处理完这条消息后 Queue 会再给该消费者发送一条消息。 交换器（Exchange） 实际的情况下，生产者将消息发送到 Exchange（交换器，下图中的 X），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。 绑定（Binding） RabbitMQ 中通过 Binding 将 Exchange 与 Queue关联起来，这样 RabbitMQ 就知道如何正确地将消息路由到指定的 Queue 了。 Routing key、Binding key 生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使用才能最终生效。 在 Exchange Type 与 binding key 固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给 Exchange 时，通过指定 routing key 来决定消息流向哪里。 RabbitMQ 为 routing key 设定的长度限制为 255 bytes。 在绑定（Binding）Exchange 与 Queue 的同时，一般会指定一个 binding key；消费者将消息发送给 Exchange 时，一般会指定一个 routing key；当 binding key 与 routing key 相匹配时，消息将会被路由到对应的 Queue 中。 Exchange Types fanout把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中。 direct 把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中。 以 routingKey=”error” 发送消息到 Exchange，则消息会路由到 Queue1（amqp.gen-S9b…，这是由 RabbitMQ 自动生成的 Queue 名称）和 Queue2（amqp.gen-Agl…）；如果我们以 routingKey=”info”或 routingKey=”warning”来发送消息，则消息只会路由到 Queue2。如果我们以其他 routingKey 发送消息，则消息不会路由到这两个 Queue 中。 topic 前面讲到 direct 类型的 Exchange 路由规则是完全匹配 binding key 与 routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic 类型的 Exchange 在匹配规则上进行了扩展，它与 direct 类型的 Exchage 相似，也是将消息路由到 binding key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定： 1&gt; routing key 为一个句点号“.”分隔的字符串（我们将被句点号“.”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” 2&gt; binding key 与 routing key 一样也是句点号“.”分隔的字符串 3&gt; binding key 中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 以上图中的配置为例， routingKey=”quick.orange.rabbit”的消息会同时路由到 Q1 与 Q2 routingKey=”lazy.orange.fox”的消息会路由到 Q1 与 Q2 routingKey=”lazy.brown.fox”的消息会路由到 Q2 routingKey=”lazy.pink.rabbit”的消息会路由到 Q2（只会投递给 Q2 一次，虽然这个 routingKey 与 Q2 的两个 bindingKey 都匹配） routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何 bindingKey。 headers headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。 在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue，否则不会路由到该 Queue。 远程调用（RPC） MQ 本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到 RabbitMQ 后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。 但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于 RPC（Remote Procedure Call，远程过程调用）。在 RabbitMQ 中也支持 RPC。 RabbitMQ 中实现 RPC 的机制是： 客户端发送请求（消息）时，在消息的属性（MessageProperties，在 AMQP 协议中定义了 14 种 properties，这些属性会随着消息一起发送）中设置两个值 replyTo（一个 Queue 名称，用于告诉服务器处理完成后将通知我的消息发送到这个 Queue 中）和 correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个 id 了解哪条请求被成功执行了或执行失败） 服务器端收到消息并处理 服务器端处理完消息后，将生成一条应答消息到 replyTo 指定的 Queue，同时带上 correlationId 属性 客户端之前已订阅 replyTo 指定的 Queue，从中收到服务器的应答消息后，根据其中的 correlationId 属性分析哪条请求被执行了，根据执行结果进行后续业务处理 参考： http://blog.csdn.net/whycold/article/details/41119807]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
